/* tslint:disable */
/* eslint-disable */
/**
 * Session API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiV1PersonaListGet200Response
 */
export interface ApiV1PersonaListGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1PersonaListGet200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1PersonaListGet200Response
     */
    'total_count': number;
    /**
     * The array of personas.
     * @type {Array<ApiV1SessionStartPost200ResponsePersona>}
     * @memberof ApiV1PersonaListGet200Response
     */
    'values': Array<ApiV1SessionStartPost200ResponsePersona>;
}
/**
 * 
 * @export
 * @interface ApiV1ScenarioListGet200Response
 */
export interface ApiV1ScenarioListGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1ScenarioListGet200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1ScenarioListGet200Response
     */
    'total_count': number;
    /**
     * The array of scenarios.
     * @type {Array<ApiV1SessionStartPost200ResponseScenario>}
     * @memberof ApiV1ScenarioListGet200Response
     */
    'values': Array<ApiV1SessionStartPost200ResponseScenario>;
}
/**
 * 
 * @export
 * @interface ApiV1SessionSessionIdGet200Response
 */
export interface ApiV1SessionSessionIdGet200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdGet200Response
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdGet200Response
     */
    'ended_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdGet200Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdGet200Response
     */
    'livekit_room': string;
    /**
     * 
     * @type {any}
     * @memberof ApiV1SessionSessionIdGet200Response
     */
    'metadata': any;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdGet200Response
     */
    'persona': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdGet200Response
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdGet200Response
     */
    'scenario': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdGet200Response
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdGet200Response
     */
    'state': ApiV1SessionSessionIdGet200ResponseStateEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdGet200Response
     */
    'voice_override'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiV1SessionSessionIdGet200Response
     */
    'time_limit_s': number;
}

export const ApiV1SessionSessionIdGet200ResponseStateEnum = {
    Ended: 'ended',
    InProgress: 'in_progress',
    NotStarted: 'not_started'
} as const;

export type ApiV1SessionSessionIdGet200ResponseStateEnum = typeof ApiV1SessionSessionIdGet200ResponseStateEnum[keyof typeof ApiV1SessionSessionIdGet200ResponseStateEnum];

/**
 * 
 * @export
 * @interface ApiV1SessionSessionIdMessagesGet200Response
 */
export interface ApiV1SessionSessionIdMessagesGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1SessionSessionIdMessagesGet200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1SessionSessionIdMessagesGet200Response
     */
    'total_count': number;
    /**
     * The array of session timeline items.
     * @type {Array<ApiV1SessionSessionIdMessagesGet200ResponseValuesInner>}
     * @memberof ApiV1SessionSessionIdMessagesGet200Response
     */
    'values': Array<ApiV1SessionSessionIdMessagesGet200ResponseValuesInner>;
}
/**
 * 
 * @export
 * @interface ApiV1SessionSessionIdMessagesGet200ResponseValuesInner
 */
export interface ApiV1SessionSessionIdMessagesGet200ResponseValuesInner {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1SessionSessionIdMessagesGet200ResponseValuesInner
     */
    'agent': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdMessagesGet200ResponseValuesInner
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdMessagesGet200ResponseValuesInner
     */
    'deleted_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdMessagesGet200ResponseValuesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdMessagesGet200ResponseValuesInner
     */
    'import_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdMessagesGet200ResponseValuesInner
     */
    'media'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdMessagesGet200ResponseValuesInner
     */
    'session': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdMessagesGet200ResponseValuesInner
     */
    'speaking_ended_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdMessagesGet200ResponseValuesInner
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1SessionSessionIdPutRequest
 */
export interface ApiV1SessionSessionIdPutRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiV1SessionSessionIdPutRequest
     */
    'time_limit_s'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdPutRequest
     */
    'voice_override'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1SessionSessionIdTimelineGet200Response
 */
export interface ApiV1SessionSessionIdTimelineGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1SessionSessionIdTimelineGet200Response
     */
    'next_page'?: string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1SessionSessionIdTimelineGet200Response
     */
    'total_count'?: number;
    /**
     * The array of session timeline items.
     * @type {Array<ApiV1SessionSessionIdTimelineGet200ResponseValuesInner>}
     * @memberof ApiV1SessionSessionIdTimelineGet200Response
     */
    'values'?: Array<ApiV1SessionSessionIdTimelineGet200ResponseValuesInner>;
}
/**
 * 
 * @export
 * @interface ApiV1SessionSessionIdTimelineGet200ResponseValuesInner
 */
export interface ApiV1SessionSessionIdTimelineGet200ResponseValuesInner {
    /**
     * 
     * @type {number}
     * @memberof ApiV1SessionSessionIdTimelineGet200ResponseValuesInner
     */
    'seconds'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionSessionIdTimelineGet200ResponseValuesInner
     */
    'type'?: ApiV1SessionSessionIdTimelineGet200ResponseValuesInnerTypeEnum;
}

export const ApiV1SessionSessionIdTimelineGet200ResponseValuesInnerTypeEnum = {
    Silence: 'silence',
    Agent: 'agent',
    User: 'user'
} as const;

export type ApiV1SessionSessionIdTimelineGet200ResponseValuesInnerTypeEnum = typeof ApiV1SessionSessionIdTimelineGet200ResponseValuesInnerTypeEnum[keyof typeof ApiV1SessionSessionIdTimelineGet200ResponseValuesInnerTypeEnum];

/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200Response
 */
export interface ApiV1SessionStartPost200Response {
    /**
     * 
     * @type {ApiV1SessionStartPost200ResponseSession}
     * @memberof ApiV1SessionStartPost200Response
     */
    'session': ApiV1SessionStartPost200ResponseSession;
    /**
     * 
     * @type {ApiV1SessionStartPost200ResponsePersona}
     * @memberof ApiV1SessionStartPost200Response
     */
    'persona'?: ApiV1SessionStartPost200ResponsePersona;
    /**
     * 
     * @type {ApiV1SessionStartPost200ResponseScenario}
     * @memberof ApiV1SessionStartPost200Response
     */
    'scenario'?: ApiV1SessionStartPost200ResponseScenario;
    /**
     * 
     * @type {ApiV1SessionStartPost200ResponseConnectionDetails}
     * @memberof ApiV1SessionStartPost200Response
     */
    'connection_details': ApiV1SessionStartPost200ResponseConnectionDetails;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200ResponseConnectionDetails
 */
export interface ApiV1SessionStartPost200ResponseConnectionDetails {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseConnectionDetails
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseConnectionDetails
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200ResponsePersona
 */
export interface ApiV1SessionStartPost200ResponsePersona {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'image_url': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'project': string;
    /**
     * 
     * @type {Array<ApiV1SessionStartPost200ResponsePersonaTagsInner>}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'tags': Array<ApiV1SessionStartPost200ResponsePersonaTagsInner>;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersona
     */
    'voice': string;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200ResponsePersonaTagsInner
 */
export interface ApiV1SessionStartPost200ResponsePersonaTagsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersonaTagsInner
     */
    'human_name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponsePersonaTagsInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200ResponseScenario
 */
export interface ApiV1SessionStartPost200ResponseScenario {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseScenario
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseScenario
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseScenario
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseScenario
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseScenario
     */
    'prompt': string;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPost200ResponseSession
 */
export interface ApiV1SessionStartPost200ResponseSession {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'ended_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'livekit_room': string;
    /**
     * 
     * @type {any}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'metadata': any;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'persona': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'scenario': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'state': ApiV1SessionStartPost200ResponseSessionStateEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'voice_override'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiV1SessionStartPost200ResponseSession
     */
    'time_limit_s': number;
}

export const ApiV1SessionStartPost200ResponseSessionStateEnum = {
    Ended: 'ended',
    InProgress: 'in_progress',
    NotStarted: 'not_started'
} as const;

export type ApiV1SessionStartPost200ResponseSessionStateEnum = typeof ApiV1SessionStartPost200ResponseSessionStateEnum[keyof typeof ApiV1SessionStartPost200ResponseSessionStateEnum];

/**
 * @type ApiV1SessionStartPostRequest
 * @export
 */
export type ApiV1SessionStartPostRequest = ApiV1SessionStartPostRequestOneOf | ApiV1SessionStartPostRequestOneOf1;

/**
 * 
 * @export
 * @interface ApiV1SessionStartPostRequestOneOf
 */
export interface ApiV1SessionStartPostRequestOneOf {
    /**
     * 
     * @type {Array<ApiV1SessionStartPostRequestOneOfHistoryInner>}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'history'?: Array<ApiV1SessionStartPostRequestOneOfHistoryInner>;
    /**
     * 
     * @type {number}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'time_limit_s'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'voice_override'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'persona'?: string;
    /**
     * save session messages
     * @type {boolean}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    'save_messages'?: boolean;
    /**
     * reserved for internal use
     * @type {object}
     * @memberof ApiV1SessionStartPostRequestOneOf
     */
    '_extra'?: object;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPostRequestOneOf1
 */
export interface ApiV1SessionStartPostRequestOneOf1 {
    /**
     * 
     * @type {number}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'time_limit_s'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'voice_override'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'llm'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'scenario'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'persona'?: string;
    /**
     * save session messages
     * @type {boolean}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    'save_messages'?: boolean;
    /**
     * reserved for internal use
     * @type {object}
     * @memberof ApiV1SessionStartPostRequestOneOf1
     */
    '_extra'?: object;
}
/**
 * 
 * @export
 * @interface ApiV1SessionStartPostRequestOneOfHistoryInner
 */
export interface ApiV1SessionStartPostRequestOneOfHistoryInner {
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOfHistoryInner
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOfHistoryInner
     */
    'import_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1SessionStartPostRequestOneOfHistoryInner
     */
    'role': ApiV1SessionStartPostRequestOneOfHistoryInnerRoleEnum;
}

export const ApiV1SessionStartPostRequestOneOfHistoryInnerRoleEnum = {
    Assistant: 'assistant',
    System: 'system',
    User: 'user'
} as const;

export type ApiV1SessionStartPostRequestOneOfHistoryInnerRoleEnum = typeof ApiV1SessionStartPostRequestOneOfHistoryInnerRoleEnum[keyof typeof ApiV1SessionStartPostRequestOneOfHistoryInnerRoleEnum];

/**
 * 
 * @export
 * @interface ApiV1UsageTokenPost200Response
 */
export interface ApiV1UsageTokenPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsageTokenPost200Response
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface ApiV1UsageTokenPutRequest
 */
export interface ApiV1UsageTokenPutRequest {
    /**
     * 
     * @type {Array<ApiV1UsageTokenPutRequestLimitsInner>}
     * @memberof ApiV1UsageTokenPutRequest
     */
    'limits': Array<ApiV1UsageTokenPutRequestLimitsInner>;
    /**
     * The ID of the human that the token is for. (this is typically your user id from your system)
     * @type {string}
     * @memberof ApiV1UsageTokenPutRequest
     */
    'human_id': string;
}
/**
 * 
 * @export
 * @interface ApiV1UsageTokenPutRequestLimitsInner
 */
export interface ApiV1UsageTokenPutRequestLimitsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsageTokenPutRequestLimitsInner
     */
    'type': ApiV1UsageTokenPutRequestLimitsInnerTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ApiV1UsageTokenPutRequestLimitsInner
     */
    'value': number;
}

export const ApiV1UsageTokenPutRequestLimitsInnerTypeEnum = {
    ConversationalSeconds: 'conversational_seconds',
    VoiceSynthesisSeconds: 'voice_synthesis_seconds',
    TokenCnt: 'token_cnt'
} as const;

export type ApiV1UsageTokenPutRequestLimitsInnerTypeEnum = typeof ApiV1UsageTokenPutRequestLimitsInnerTypeEnum[keyof typeof ApiV1UsageTokenPutRequestLimitsInnerTypeEnum];

/**
 * 
 * @export
 * @interface ApiV1VoiceClonePost200Response
 */
export interface ApiV1VoiceClonePost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1VoiceClonePost200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1VoiceGeneratePostRequest
 */
export interface ApiV1VoiceGeneratePostRequest {
    /**
     * Text to synthesize into voice
     * @type {string}
     * @memberof ApiV1VoiceGeneratePostRequest
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1VoiceGeneratePostRequest
     */
    'voice_id': string;
}
/**
 * 
 * @export
 * @interface ApiV1VoiceListGet200Response
 */
export interface ApiV1VoiceListGet200Response {
    /**
     * The token for the next page of results, or null if there are no more pages.
     * @type {string}
     * @memberof ApiV1VoiceListGet200Response
     */
    'next_page': string;
    /**
     * The total number of items available.
     * @type {number}
     * @memberof ApiV1VoiceListGet200Response
     */
    'total_count': number;
    /**
     * The array of voices.
     * @type {Array<ApiV1VoiceListGet200ResponseValuesInner>}
     * @memberof ApiV1VoiceListGet200Response
     */
    'values': Array<ApiV1VoiceListGet200ResponseValuesInner>;
}
/**
 * 
 * @export
 * @interface ApiV1VoiceListGet200ResponseValuesInner
 */
export interface ApiV1VoiceListGet200ResponseValuesInner {
    /**
     * 
     * @type {string}
     * @memberof ApiV1VoiceListGet200ResponseValuesInner
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1VoiceListGet200ResponseValuesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1VoiceListGet200ResponseValuesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1VoiceListGet200ResponseValuesInner
     */
    'language': string;
}
/**
 * 
 * @export
 * @interface ApiV1VoicePreviewPostRequest
 */
export interface ApiV1VoicePreviewPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1VoicePreviewPostRequest
     */
    'voice': string;
}

/**
 * PersonaApi - axios parameter creator
 * @export
 */
export const PersonaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of personas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonaListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/persona/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonaApi - functional programming interface
 * @export
 */
export const PersonaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of personas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PersonaListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1PersonaListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PersonaListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiV1PersonaListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PersonaApi - factory interface
 * @export
 */
export const PersonaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonaApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of personas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PersonaListGet(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1PersonaListGet200Response> {
            return localVarFp.apiV1PersonaListGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonaApi - object-oriented interface
 * @export
 * @class PersonaApi
 * @extends {BaseAPI}
 */
export class PersonaApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of personas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiV1PersonaListGet(options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiV1PersonaListGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScenarioApi - axios parameter creator
 * @export
 */
export const ScenarioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of scenarios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScenarioListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/scenario/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScenarioApi - functional programming interface
 * @export
 */
export const ScenarioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScenarioApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of scenarios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScenarioListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ScenarioListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ScenarioListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.apiV1ScenarioListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScenarioApi - factory interface
 * @export
 */
export const ScenarioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScenarioApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of scenarios
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScenarioListGet(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ScenarioListGet200Response> {
            return localVarFp.apiV1ScenarioListGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScenarioApi - object-oriented interface
 * @export
 * @class ScenarioApi
 * @extends {BaseAPI}
 */
export class ScenarioApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of scenarios
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public apiV1ScenarioListGet(options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).apiV1ScenarioListGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary End a session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdEndPost: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdEndPost', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}/end`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a session by id
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdGet: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdGet', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get session messages
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdMessagesGet: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdMessagesGet', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}/messages`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a session by id
         * @param {string} sessionId 
         * @param {ApiV1SessionSessionIdPutRequest} apiV1SessionSessionIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdPut: async (sessionId: string, apiV1SessionSessionIdPutRequest: ApiV1SessionSessionIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdPut', 'sessionId', sessionId)
            // verify required parameter 'apiV1SessionSessionIdPutRequest' is not null or undefined
            assertParamExists('apiV1SessionSessionIdPut', 'apiV1SessionSessionIdPutRequest', apiV1SessionSessionIdPutRequest)
            const localVarPath = `/api/v1/session/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1SessionSessionIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a session timeline
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdTimelineGet: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('apiV1SessionSessionIdTimelineGet', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}/timeline`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new session based on the input request data
         * @summary Create a new session
         * @param {ApiV1SessionStartPostRequest} apiV1SessionStartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionStartPost: async (apiV1SessionStartPostRequest: ApiV1SessionStartPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1SessionStartPostRequest' is not null or undefined
            assertParamExists('apiV1SessionStartPost', 'apiV1SessionStartPostRequest', apiV1SessionStartPostRequest)
            const localVarPath = `/api/v1/session/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1SessionStartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary End a session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdEndPost(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionStartPost200ResponseSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdEndPost(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdEndPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a session by id
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdGet(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionSessionIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get session messages
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdMessagesGet(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionSessionIdMessagesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdMessagesGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdMessagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a session by id
         * @param {string} sessionId 
         * @param {ApiV1SessionSessionIdPutRequest} apiV1SessionSessionIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdPut(sessionId: string, apiV1SessionSessionIdPutRequest: ApiV1SessionSessionIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdPut(sessionId, apiV1SessionSessionIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a session timeline
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionSessionIdTimelineGet(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionSessionIdTimelineGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdTimelineGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdTimelineGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new session based on the input request data
         * @summary Create a new session
         * @param {ApiV1SessionStartPostRequest} apiV1SessionStartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SessionStartPost(apiV1SessionStartPostRequest: ApiV1SessionStartPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionStartPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionStartPost(apiV1SessionStartPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionStartPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionApiFp(configuration)
    return {
        /**
         * 
         * @summary End a session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdEndPost(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionStartPost200ResponseSession> {
            return localVarFp.apiV1SessionSessionIdEndPost(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a session by id
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdGet(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionSessionIdGet200Response> {
            return localVarFp.apiV1SessionSessionIdGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get session messages
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdMessagesGet(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionSessionIdMessagesGet200Response> {
            return localVarFp.apiV1SessionSessionIdMessagesGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a session by id
         * @param {string} sessionId 
         * @param {ApiV1SessionSessionIdPutRequest} apiV1SessionSessionIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdPut(sessionId: string, apiV1SessionSessionIdPutRequest: ApiV1SessionSessionIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiV1SessionSessionIdPut(sessionId, apiV1SessionSessionIdPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a session timeline
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionSessionIdTimelineGet(sessionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionSessionIdTimelineGet200Response> {
            return localVarFp.apiV1SessionSessionIdTimelineGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new session based on the input request data
         * @summary Create a new session
         * @param {ApiV1SessionStartPostRequest} apiV1SessionStartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SessionStartPost(apiV1SessionStartPostRequest: ApiV1SessionStartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionStartPost200Response> {
            return localVarFp.apiV1SessionStartPost(apiV1SessionStartPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @summary End a session
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdEndPost(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdEndPost(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a session by id
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdGet(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get session messages
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdMessagesGet(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdMessagesGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a session by id
     * @param {string} sessionId 
     * @param {ApiV1SessionSessionIdPutRequest} apiV1SessionSessionIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdPut(sessionId: string, apiV1SessionSessionIdPutRequest: ApiV1SessionSessionIdPutRequest, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdPut(sessionId, apiV1SessionSessionIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a session timeline
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionSessionIdTimelineGet(sessionId: string, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionSessionIdTimelineGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new session based on the input request data
     * @summary Create a new session
     * @param {ApiV1SessionStartPostRequest} apiV1SessionStartPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public apiV1SessionStartPost(apiV1SessionStartPostRequest: ApiV1SessionStartPostRequest, options?: RawAxiosRequestConfig) {
        return SessionApiFp(this.configuration).apiV1SessionStartPost(apiV1SessionStartPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsageApi - axios parameter creator
 * @export
 */
export const UsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the usage limits of a token
         * @summary Get usage limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsageLimitsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/usage/limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests a token for a human
         * @summary Request new human token
         * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsageTokenPost: async (apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1UsageTokenPutRequest' is not null or undefined
            assertParamExists('apiV1UsageTokenPost', 'apiV1UsageTokenPutRequest', apiV1UsageTokenPutRequest)
            const localVarPath = `/api/v1/usage/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UsageTokenPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the usage limits of a human
         * @summary Update human usage limits
         * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsageTokenPut: async (apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1UsageTokenPutRequest' is not null or undefined
            assertParamExists('apiV1UsageTokenPut', 'apiV1UsageTokenPutRequest', apiV1UsageTokenPutRequest)
            const localVarPath = `/api/v1/usage/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UsageTokenPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageApi - functional programming interface
 * @export
 */
export const UsageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets the usage limits of a token
         * @summary Get usage limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsageLimitsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1UsageTokenPutRequestLimitsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsageLimitsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.apiV1UsageLimitsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requests a token for a human
         * @summary Request new human token
         * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsageTokenPost(apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1UsageTokenPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsageTokenPost(apiV1UsageTokenPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.apiV1UsageTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the usage limits of a human
         * @summary Update human usage limits
         * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsageTokenPut(apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsageTokenPut(apiV1UsageTokenPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.apiV1UsageTokenPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsageApi - factory interface
 * @export
 */
export const UsageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageApiFp(configuration)
    return {
        /**
         * Gets the usage limits of a token
         * @summary Get usage limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsageLimitsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiV1UsageTokenPutRequestLimitsInner>> {
            return localVarFp.apiV1UsageLimitsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Requests a token for a human
         * @summary Request new human token
         * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsageTokenPost(apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1UsageTokenPost200Response> {
            return localVarFp.apiV1UsageTokenPost(apiV1UsageTokenPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the usage limits of a human
         * @summary Update human usage limits
         * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsageTokenPut(apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiV1UsageTokenPut(apiV1UsageTokenPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageApi - object-oriented interface
 * @export
 * @class UsageApi
 * @extends {BaseAPI}
 */
export class UsageApi extends BaseAPI {
    /**
     * Gets the usage limits of a token
     * @summary Get usage limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public apiV1UsageLimitsGet(options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).apiV1UsageLimitsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requests a token for a human
     * @summary Request new human token
     * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public apiV1UsageTokenPost(apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).apiV1UsageTokenPost(apiV1UsageTokenPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the usage limits of a human
     * @summary Update human usage limits
     * @param {ApiV1UsageTokenPutRequest} apiV1UsageTokenPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public apiV1UsageTokenPut(apiV1UsageTokenPutRequest: ApiV1UsageTokenPutRequest, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).apiV1UsageTokenPut(apiV1UsageTokenPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VoiceApi - axios parameter creator
 * @export
 */
export const VoiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {string} name Name of the new voice
         * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
         * @param {File} file Audio file for voice cloning (MP3 format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceClonePost: async (name: string, language: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('apiV1VoiceClonePost', 'name', name)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('apiV1VoiceClonePost', 'language', language)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('apiV1VoiceClonePost', 'file', file)
            const localVarPath = `/api/v1/voice/clone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (language !== undefined) { 
                localVarFormParams.append('language', language as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {ApiV1VoiceGeneratePostRequest} apiV1VoiceGeneratePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceGeneratePost: async (apiV1VoiceGeneratePostRequest: ApiV1VoiceGeneratePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1VoiceGeneratePostRequest' is not null or undefined
            assertParamExists('apiV1VoiceGeneratePost', 'apiV1VoiceGeneratePostRequest', apiV1VoiceGeneratePostRequest)
            const localVarPath = `/api/v1/voice/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1VoiceGeneratePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of voices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/voice/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Previews a voice based on the input text
         * @summary Preview a voice
         * @param {ApiV1VoicePreviewPostRequest} apiV1VoicePreviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoicePreviewPost: async (apiV1VoicePreviewPostRequest: ApiV1VoicePreviewPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1VoicePreviewPostRequest' is not null or undefined
            assertParamExists('apiV1VoicePreviewPost', 'apiV1VoicePreviewPostRequest', apiV1VoicePreviewPostRequest)
            const localVarPath = `/api/v1/voice/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1VoicePreviewPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoiceApi - functional programming interface
 * @export
 */
export const VoiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VoiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {string} name Name of the new voice
         * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
         * @param {File} file Audio file for voice cloning (MP3 format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1VoiceClonePost(name: string, language: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1VoiceClonePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1VoiceClonePost(name, language, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.apiV1VoiceClonePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {ApiV1VoiceGeneratePostRequest} apiV1VoiceGeneratePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1VoiceGeneratePost(apiV1VoiceGeneratePostRequest: ApiV1VoiceGeneratePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1VoiceGeneratePost(apiV1VoiceGeneratePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.apiV1VoiceGeneratePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of voices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1VoiceListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1VoiceListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1VoiceListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.apiV1VoiceListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Previews a voice based on the input text
         * @summary Preview a voice
         * @param {ApiV1VoicePreviewPostRequest} apiV1VoicePreviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1VoicePreviewPost(apiV1VoicePreviewPostRequest: ApiV1VoicePreviewPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1VoicePreviewPost(apiV1VoicePreviewPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceApi.apiV1VoicePreviewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VoiceApi - factory interface
 * @export
 */
export const VoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VoiceApiFp(configuration)
    return {
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {string} name Name of the new voice
         * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
         * @param {File} file Audio file for voice cloning (MP3 format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceClonePost(name: string, language: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1VoiceClonePost200Response> {
            return localVarFp.apiV1VoiceClonePost(name, language, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new cloned voice based on the input audio file
         * @summary Clone a voice
         * @param {ApiV1VoiceGeneratePostRequest} apiV1VoiceGeneratePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceGeneratePost(apiV1VoiceGeneratePostRequest: ApiV1VoiceGeneratePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.apiV1VoiceGeneratePost(apiV1VoiceGeneratePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of voices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoiceListGet(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1VoiceListGet200Response> {
            return localVarFp.apiV1VoiceListGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Previews a voice based on the input text
         * @summary Preview a voice
         * @param {ApiV1VoicePreviewPostRequest} apiV1VoicePreviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoicePreviewPost(apiV1VoicePreviewPostRequest: ApiV1VoicePreviewPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.apiV1VoicePreviewPost(apiV1VoicePreviewPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoiceApi - object-oriented interface
 * @export
 * @class VoiceApi
 * @extends {BaseAPI}
 */
export class VoiceApi extends BaseAPI {
    /**
     * Creates a new cloned voice based on the input audio file
     * @summary Clone a voice
     * @param {string} name Name of the new voice
     * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
     * @param {File} file Audio file for voice cloning (MP3 format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public apiV1VoiceClonePost(name: string, language: string, file: File, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).apiV1VoiceClonePost(name, language, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new cloned voice based on the input audio file
     * @summary Clone a voice
     * @param {ApiV1VoiceGeneratePostRequest} apiV1VoiceGeneratePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public apiV1VoiceGeneratePost(apiV1VoiceGeneratePostRequest: ApiV1VoiceGeneratePostRequest, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).apiV1VoiceGeneratePost(apiV1VoiceGeneratePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of voices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public apiV1VoiceListGet(options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).apiV1VoiceListGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Previews a voice based on the input text
     * @summary Preview a voice
     * @param {ApiV1VoicePreviewPostRequest} apiV1VoicePreviewPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    public apiV1VoicePreviewPost(apiV1VoicePreviewPostRequest: ApiV1VoicePreviewPostRequest, options?: RawAxiosRequestConfig) {
        return VoiceApiFp(this.configuration).apiV1VoicePreviewPost(apiV1VoicePreviewPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



